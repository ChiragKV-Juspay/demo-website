// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var baseUrl = "https://sl-dkls23-passkeys.silencelaboratories.com";

console.log("USEPASSKEYS LOADED");

async function registerWithPasskeys(userId) {
  console.log(userId);
  var urlSafeBase64Encode = function (value) {
    return new TextEncoder().encode(value).buffer;
  };
  var arrayBufferToBase64Url = function (arrayBuffer) {
    console.log(arrayBuffer);
    var bytes = Curry._1(new Uint8Array(), arrayBuffer);
    console.log(bytes);
    var binaryString = Belt_Array.reduce(bytes, "", (function (acc, $$byte) {
            return acc + String.fromCharCode($$byte);
          }));
    console.log(binaryString);
    var base64 = Curry._1(new btoa(), binaryString);
    console.log(base64);
    return Js_string.replace(Js_string.replace(Js_string.replace(base64, "+", "-"), "/", "_"), "=", "");
  };
  var challengePromises = Belt_Array.makeBy(3, (function (i) {
          console.log(i);
          var url = baseUrl + "/auth-" + String(i) + "/issue_passkeys_challenge";
          var fetchChallenge = async function () {
            var response = await fetch(url);
            if (response.status === 200) {
              return await response.json();
            } else {
              return Js_exn.raiseError("Error fetching challenge from " + url);
            }
          };
          return fetchChallenge();
        }));
  console.log("Fetching challenges from nodes...");
  var challenges1 = await Promise.all(challengePromises);
  var challenges = [
    "",
    "",
    ""
  ];
  console.log("Challenges:");
  console.log(challenges1);
  var timeNow = new Date();
  var setup_sl_mpc_setup = {
    keygen: {
      n: 3,
      t: 2
    }
  };
  var setup = {
    sl_mpc_setup: setup_sl_mpc_setup,
    timeout: 60,
    challenges: challenges,
    time: timeNow
  };
  var setupString = Belt_Option.getExn(JSON.stringify(setup));
  var challenge = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(setupString));
  console.log("Challenge:");
  var options = {
    publicKey: {
      authenticatorSelection: {
        residentKey: "preferred",
        requireResidentKey: false,
        userVerification: "required"
      },
      challenge: challenge,
      excludeCredentials: [],
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
        },
        {
          type: "public-key",
          alg: -257
        }
      ],
      rp: {
        name: "http://localhost:3001",
        id: "localhost"
      },
      user: {
        name: userId,
        displayName: userId,
        id: urlSafeBase64Encode(userId)
      }
    }
  };
  console.log("Options:");
  console.log(options);
  var my_cred = await navigator.credentials.create(options);
  console.log("Credentials:");
  console.log(my_cred);
  if (my_cred === null) {
    Js_exn.raiseError("No credential returned");
  }
  var my_cred_json = Belt_Option.getExn(JSON.stringify(Object.fromEntries([
                [
                  "authenticatorAttachment",
                  my_cred.authenticatorAttachment
                ],
                [
                  "id",
                  my_cred.id
                ],
                [
                  "rawId",
                  arrayBufferToBase64Url(my_cred.rawId)
                ],
                [
                  "response",
                  Object.fromEntries([
                        [
                          "attestationObject",
                          arrayBufferToBase64Url(my_cred.response.attestationObject)
                        ],
                        [
                          "clientDataJSON",
                          arrayBufferToBase64Url(my_cred.response.clientDataJSON)
                        ]
                      ])
                ],
                [
                  "type",
                  my_cred.type
                ]
              ])));
  console.log("As JSON:");
  console.log(JSON.parse(my_cred_json));
  var registrationPromises = Belt_Array.makeBy(3, (function (i) {
          var url = baseUrl + "/auth-" + String(i) + "/verify_passkeys_registration";
          var body = Belt_Option.getExn(JSON.stringify({
                    raw_credential: my_cred_json,
                    user: options.publicKey.user,
                    setup_string: setupString,
                    setup: setup,
                    origin: "http://localhost:3001",
                    rp_id: "localhost"
                  }));
          var fetchRegistration = async function () {
            var response = await fetch(url, {
                  method: "POST",
                  body: Caml_option.some(body),
                  headers: Caml_option.some(new Headers({
                            "Content-Type": "application/json"
                          }))
                });
            if (response.status === 200) {
              console.log("Registered ok!");
              return response.json();
            } else {
              return Js_exn.raiseError("Error validating registration with " + url);
            }
          };
          return fetchRegistration();
        }));
  console.log("Validating registration with nodes...");
  var registrationResponses = await Promise.all(registrationPromises);
  console.log("Registration responses:");
  console.log(registrationResponses);
  Belt_Array.getExn(registrationResponses, 0);
  for(var i = 1; i <= 2; ++i){
    Belt_Array.getExn(registrationResponses, i);
  }
}

var rpConfig = {
  rpName: "http://localhost:3001",
  rpId: "localhost"
};

export {
  baseUrl ,
  rpConfig ,
  registerWithPasskeys ,
}
/*  Not a pure module */
